# Day 13: Part 2 

## Problem Description
In this part, the goal was to extend the comparison logic to accommodate additional rules for ordering. The new rules may involve more complex relationships between the elements in the pairs, requiring a more sophisticated approach to determine their order.

## Approach
To tackle this problem, I followed these steps:
1. **Reuse Previous Logic**: I reused the input reading and pair parsing logic from Part 1 to maintain consistency.
2. **Adjust Comparison Logic**: I modified the comparison function to incorporate the new rules for ordering. This may involve additional conditions or different criteria for comparison.
3. **Count Ordered Pairs**: I iterated through the list of pairs again, applying the updated comparison logic to evaluate their order.
4. **Output**: Finally, I printed the count of correctly ordered pairs based on the new rules.

This approach builds on the previous logic while adding the complexity of the new ordering criteria.

## Key Insights
- Extending existing comparison logic can be done efficiently by building on previous implementations.
- Clear documentation of new rules is essential for maintaining code clarity.

## Concepts and Algorithms Used
- **Input Handling**: Reading from files and processing strings.
- **Data Structures**: Lists for storing pairs of elements.
- **Algorithms**: Custom comparison logic with adjusted rules for ordering.